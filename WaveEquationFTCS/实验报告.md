# 项目：波动方程的FTCS解 - 实验报告

**学生姓名：** [杨飞扬] **学号：** [20231050194] **完成日期：** [2025年6月18日]

## 1. 实验目的

本实验旨在通过有限差分法（FTCS方案）模拟一维波动方程，理解其数值求解过程，并可视化弦的振动。

## 2. 核心算法

### 2.1 算法思路

本实验采用FTCS（Forward-Time Central-Space）方案求解一维波动方程。首先，将连续的波动方程离散化为差分方程。然后，根据给定的初始条件（初始位移和初始速度）计算第一个时间步的弦位移。接着，通过迭代更新公式，从已知的前两个时间步的位移计算出当前时间步的位移，直到模拟结束。在整个过程中，严格遵守边界条件，即弦的两端位移始终为零。

### 2.2 关键代码片段

```python
"""
Module: WaveEquationFTCS Solution
File: wave_equation_ftcs_solution.py

该模块使用FTCS（Forward-Time Central-Space）有限差分法求解一维波动方程。
波动方程形式：∂²u/∂t² = a² * ∂²u/∂x²
"""
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

def u_t(x, C=1, d=0.1, sigma=0.3, L=1):
    """
    计算初始速度分布ψ(x) = ∂u/∂t(t=0)
    Args:
        x (np.ndarray): 位置坐标数组
        C (float): 振幅常数，控制初始速度的强度
        d (float): 高斯分布中心偏移量
        sigma (float): 高斯分布宽度参数
        L (float): 弦的长度
    Returns:
        np.ndarray: 初始速度分布
    """
    # 公式：C * x(L-x)/L² * exp(-(x-d)²/(2σ²))
    # 该函数表示初始时刻(t=0)弦上各点的速度分布
    return C * x * (L - x) / L / L * np.exp(-(x - d)**2 / (2 * sigma**2))

def solve_wave_equation_ftcs(parameters):
    """
    使用FTCS有限差分法求解一维波动方程
    
    Args:
        parameters (dict): 包含模拟参数的字典:
            - 'a': 波速 (m/s)
            - 'L': 弦长度 (m)
            - 'd': 初始速度分布的偏移量 (m)
            - 'C': 初始速度分布的振幅常数 (m/s)
            - 'sigma': 初始速度分布的宽度参数 (m)
            - 'dx': 空间步长 (m)
            - 'dt': 时间步长 (s)
            - 'total_time': 总模拟时间 (s)
            
    Returns:
        tuple: 包含以下内容的元组:
            - u: 二维数组，波动方程的解 u(x, t)
            - x: 空间坐标数组
            - t: 时间坐标数组
    """
    # 从参数字典获取参数，使用默认值确保参数完整性
    a = parameters.get('a', 100)        # 波速 (默认100 m/s)
    L = parameters.get('L', 1)          # 弦长 (默认1 m)
    d = parameters.get('d', 0.1)        # 初始速度偏移 (默认0.1 m)
    C = parameters.get('C', 1)          # 初始速度振幅 (默认1 m/s)
    sigma = parameters.get('sigma', 0.3) # 初始速度分布宽度 (默认0.3 m)
    dx = parameters.get('dx', 0.01)     # 空间步长 (默认0.01 m)
    dt = parameters.get('dt', 5e-5)     # 时间步长 (默认0.00005 s)
    total_time = parameters.get('total_time', 0.1)  # 总时间 (默认0.1 s)

    # 创建空间和时间网格
    x = np.arange(0, L + dx, dx)  # 空间网格 (0到L，步长dx)
    t = np.arange(0, total_time + dt, dt)  # 时间网格 (0到total_time，步长dt)
    
    # 初始化解矩阵 u(x, t)
    u = np.zeros((x.size, t.size), float)

    # 计算稳定性参数 c = (a*dt/dx)²
    c_val = (a * dt / dx)**2
    
    # 检查CFL稳定性条件 (c < 1)
    if c_val >= 1:
        print(f"警告: 稳定性条件 c = {c_val} ≥ 1. 解可能不稳定.")

    # 设置初始条件:
    # 条件1: u(x, 0) = 0 (初始位移为零 - 弦静止)
    # 条件2: ∂u/∂t(t=0) = ψ(x) (初始速度分布)
    
    # 计算第一个时间步 (j=1) 的解:
    # 使用中心差分近似初始速度项
    # 公式: u_i,1 = c/2 * (u_i+1,0 + u_i-1,0) + (1-c) * u_i,0 + ψ(x_i) * dt
    # 由于初始位移 u_i,0 = 0, 简化为:
    # u_i,1 = ψ(x_i) * dt
    u[1:-1, 1] = u_t(x[1:-1], C, d, sigma, L) * dt

    # 使用FTCS格式进行后续时间步的迭代 (j ≥ 2)
    # 公式: u_i,j+1 = c * (u_i+1,j + u_i-1,j) + 2*(1-c)*u_i,j - u_i,j-1
    for j in range(1, t.size - 1):
        u[1:-1, j + 1] = c_val * (u[2:, j] + u[:-2, j]) + 2 * (1 - c_val) * u[1:-1, j] - u[1:-1, j - 1]

    return u, x, t

if __name__ == "__main__":
    # 演示和测试代码
    # 设置模拟参数
    params = {
        'a': 100,          # 波速 100 m/s
        'L': 1,             # 弦长 1 m
        'd': 0.1,           # 初始速度偏移 0.1 m
        'C': 1,             # 初始速度振幅 1 m/s
        'sigma': 0.3,       # 初始速度分布宽度 0.3 m
        'dx': 0.01,         # 空间步长 0.01 m
        'dt': 5e-5,         # 时间步长 0.00005 s
        'total_time': 0.1    # 总模拟时间 0.1 s
    }
    
    # 求解波动方程
    u_sol, x_sol, t_sol = solve_wave_equation_ftcs(params)

    # 创建动画可视化结果
    fig = plt.figure(figsize=(10, 6))
    ax = fig.add_subplot(111, xlim=(0, params['L']), ylim=(u_sol.min() * 1.1, u_sol.max() * 1.1))
    line, = ax.plot([], [], 'g-', lw=2)  # 创建绿色线条对象
    ax.set_title("一维波动方程求解 (FTCS方法)")
    ax.set_xlabel("位置 (m)")
    ax.set_ylabel("位移")

    # 动画更新函数
    def update(frame):
        """更新动画帧，显示特定时间步的波形"""
        line.set_data(x_sol, u_sol[:, frame])
        return line,

    # 创建动画对象
    # frames: 总帧数（时间步数）
    # interval: 帧间隔时间（毫秒）
    # blit: 使用blitting技术优化渲染
    ani = FuncAnimation(fig, update, frames=t_sol.size, interval=1, blit=True)
    
    # 显示动画
    plt.show()
```

## 3. 实验结果

### 3.1 主要输出

![wave_equation_simulation](https://github.com/user-attachments/assets/d7990c39-8fbe-43fe-9f61-6c2df09ec185)


### 3.2 结果验证
### 波动方程数值解验证方法
1. 边界条件验证：
   检查弦两端位移在整个模拟中是否严格保持为零（固定边界），最大偏差应小于10⁻¹⁴（浮点精度极限）。
2. 初始条件验证：
   确认初始位移为零且初始速度分布符合ψ(x)函数，速度分布误差应小于10⁻³。
3. 波速验证：
   测量波前传播速度应与设定波速a的误差小于1%（如100m/s系统实测值在99-101m/s间）。
4. 能量守恒验证：
   计算系统总动能与势能之和，其相对变化率应小于2%，无持续增长趋势。
5. 收敛性验证：
   网格加密时解误差应以二阶精度减小（收敛阶≈2.0），符合FTCS方法理论特性。
6. 稳定性验证：
   当CFL=(a·Δt/Δx)²<1时解稳定无振荡；若≥1则出现发散（通过参数测试验证）。

## 4. 问题与收获

### 4.1 主要问题

[请在此处列出你在实验过程中遇到的1-2个主要困难，例如：
*   如何处理初始速度条件？
*   如何确保数值稳定性？
*   动画制作中的挑战？]

### 4.2 解决方法

[请在此处描述你如何解决上述问题。例如：
*   查阅资料理解初始速度的离散化方法。
*   调整时间步长以满足CFL条件。
*   学习Matplotlib动画模块的使用。]

### 4.3 主要收获

[请在此处总结你在本次实验中的3-5句话学习收获，例如：
*   加深了对波动方程和有限差分法的理解。
*   掌握了Python进行科学计算和可视化的技能。
*   认识到数值模拟中稳定性条件的重要性。]

## 5. 思考题（可选）

1.  如果改变初始速度剖面 $\psi(x)$ 的形状，弦的振动模式会有什么变化？
2.  尝试使用不同的 $\Delta t$ 和 $\Delta x$ 值，观察数值解的稳定性和准确性如何受到影响。当 $c \ge 1$ 时会发生什么？
